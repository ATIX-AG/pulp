diff -Naur M2Crypto-0.21.1.orig/M2Crypto/X509.py M2Crypto-0.21.1.pulp/M2Crypto/X509.py
--- M2Crypto-0.21.1.orig/M2Crypto/X509.py	2011-08-29 11:00:49.316953499 -0400
+++ M2Crypto-0.21.1.pulp/M2Crypto/X509.py	2011-08-30 17:23:21.955158000 -0400
@@ -234,7 +234,7 @@
         else:
             self.x509_name = m2.x509_name_new ()
             self._pyfree = 1
-            
+
     def __del__(self):
         if getattr(self, '_pyfree', 0):
             self.m2_x509_name_free(self.x509_name)
@@ -560,7 +560,7 @@
             return m2.x509_verify(self.x509, pkey.pkey)
         else:
             return m2.x509_verify(self.x509, self.get_pubkey().pkey)
-            
+    
     def check_ca(self):
         """
         Check if the certificate is a Certificate Authority (CA) certificate.
@@ -677,17 +677,21 @@
 
     m2_x509_store_ctx_free = m2.x509_store_ctx_free
 
-    def __init__(self, x509_store_ctx, _pyfree=0):
-        self.ctx = x509_store_ctx
-        self._pyfree = _pyfree
-        
+    def __init__(self, x509_store_ctx=None, _pyfree=0):
+        if x509_store_ctx is not None:
+            self.ctx = x509_store_ctx
+            self._pyfree = _pyfree
+        else:
+            self.ctx = m2.x509_store_ctx_new()
+            self._pyfree = 1
+
     def __del__(self):
-        if self._pyfree:
+        if getattr(self, '_pyfree', 0):
             self.m2_x509_store_ctx_free(self.ctx)
-            
+
     def _ptr(self):
         return self.ctx
-            
+
     def get_current_cert(self):
         """
         Get current X.509 certificate.
@@ -718,7 +722,44 @@
         @rtype:  X509_Stack
         """
         return X509_Stack(m2.x509_store_ctx_get1_chain(self.ctx), 1, 1)
-        
+   
+    def init(self, store, cert, untrusted=None):
+        """
+        Initialization context to allow certificate verification 
+
+        @type store: X509_Store
+        @param store: X509_Store containing CA and flags set for verification
+
+        @type cert: X509
+        @param cert: X509 certificate to add to context for verification
+
+        @type untrusted: X509_Stack 
+        @param untrusted: untrusted chain, default None
+        """
+        assert isinstance(store, X509_Store)
+        assert isinstance(cert, X509)
+        untrusted_ptr = None
+        if untrusted:
+            assert isinstance(untrusted, X509_Stack)
+            untrusted_ptr = untrusted._ptr()
+        ret = m2.x509_store_ctx_init(self.ctx, store._ptr(), cert._ptr(), untrusted_ptr)
+        if ret < 1:
+            raise X509Error(Err.get_error())
+
+    def add_crls(self, crls):
+        """
+        Add CRLs to this context
+        @type crls: CRL_Stack
+        @param crls: Stack of CRLs
+        """
+        assert isinstance(crls, CRL_Stack)
+        m2.x509_store_ctx_set0_crls(self.ctx, crls._ptr())
+
+    def verify_cert(self):
+        """
+        Verify certificate
+        """
+        return m2.x509_verify_cert(self.ctx)
 
 class X509_Store:
     """
@@ -754,6 +795,19 @@
         assert isinstance(x509, X509)
         return m2.x509_store_add_cert(self.store, x509._ptr())
         
+    def add_crl(self, crl):
+        assert isinstance(crl, CRL)
+        ret = m2.x509_store_add_crl(self.store, crl._ptr())
+        if ret < 1:
+            raise X509Error(Err.get_error())
+        return ret
+
+    def set_flags(self, flags):
+        ret = m2.x509_store_set_flags(self.store, flags)
+        if ret < 1:
+            raise X509Error(Err.get_error())
+        return ret
+        
     add_cert = add_x509
 
 
@@ -845,6 +899,75 @@
         raise X509Error(Err.get_error())
     return X509_Stack(stack_ptr, 1, 1)
 
+class CRL_Stack:
+    """
+    A 'CRL Stack', maps to STACK_OF(X509_CRL)
+
+    @warning: Do not modify the underlying OpenSSL stack
+    except through this interface, or use any OpenSSL functions that do so
+    indirectly. Doing so will get the OpenSSL stack and the Ginternal pystack
+    of this class out of sync, leading to python memory leaks, exceptions
+    or even python crashes!
+    """
+    
+    m2_sk_x509_crl_free = m2.sk_x509_crl_free
+
+    def __init__(self, stack=None, _pyfree=0, _pyfree_x509_crl=0):
+        if stack is not None:
+            self.stack = stack
+            self._pyfree = _pyfree
+            self.pystack = [] # This must be kept in sync with self.stack
+            num = m2.sk_x509_crl_num(self.stack)
+            for i in range(num):
+                self.pystack.append(CRL(m2.sk_x509_crl_value(self.stack, i),
+                                         _pyfree=_pyfree_x509_crl))
+        else:
+            self.stack = m2.sk_x509_crl_new_null()
+            self._pyfree = 1
+            self.pystack = [] # This must be kept in sync with self.stack
+    
+    def __del__(self):
+        if getattr(self, '_pyfree', 0):
+            self.m2_sk_x509_crl_free(self.stack)
+    
+    def __len__(self):
+        assert m2.sk_x509_crl_num(self.stack) == len(self.pystack)
+        return len(self.pystack)
+
+    def __getitem__(self, idx):
+        return self.pystack[idx]
+    
+    def __iter__(self):
+        return iter(self.pystack)
+
+    def _ptr(self):
+        return self.stack
+    
+    def push(self, crl):
+        """
+        push a CRL certificate onto the stack.
+        
+        @param crl: CRL object.
+        @return: The number of CRL objects currently on the stack.
+        """
+        assert isinstance(crl, CRL)
+        self.pystack.append(crl)
+        ret = m2.sk_x509_crl_push(self.stack, crl._ptr())
+        assert ret == len(self.pystack)
+        return ret
+
+    def pop(self):
+        """
+        pop a CRL from the stack.
+        
+        @return: CRL object that was popped, or None if there is nothing
+        to pop. 
+        """
+        crl_ptr = m2.sk_x509_crl_pop(self.stack)
+        if crl_ptr is None:
+            assert len(self.pystack) == 0
+            return None
+        return self.pystack.pop()
 
 class Request:
     """
@@ -1067,7 +1190,7 @@
         else:
             self.crl = m2.x509_crl_new()
             self._pyfree = 1
-            
+
     def __del__(self):
         if getattr(self, '_pyfree', 0):
             self.m2_x509_crl_free(self.crl)
@@ -1082,7 +1205,25 @@
         buf=BIO.MemoryBuffer()
         m2.x509_crl_print(buf.bio_ptr(), self.crl)
         return buf.read_all()
+    
+    def get_issuer(self):
+        """
+        Return the Issuer Name
 
+        @rtype: X509_Name
+        @return: X509_Name of the issuer
+
+        Warning: X509_Name is tied to the CRL.  If the CRL goes out of scope
+        so does the underlying X509_Name of the issuer
+        """
+        crl_issuer_x509_name = m2.x509_crl_get_issuer(self.crl)
+        return X509_Name(crl_issuer_x509_name)
+
+    def _ptr(self):
+        return self.crl
+
+    def verify(self, pkey):
+        return m2.x509_crl_verify(self.crl, pkey.pkey)
 
 def load_crl(file):
     """
@@ -1101,4 +1242,20 @@
         raise X509Error(Err.get_error())
     return CRL(cptr, 1)
 
+def load_crl_string(crl_string):
+    """
+    Load CRL from a string.
+
+    @type string: string
+    @param string: String containing a CRL in PEM format.
+
+    @rtype: M2Crypto.X509.X509_CRL
+    @return: M2Crypto.X509.X509_CRL object.
+    """
+    bio = BIO.MemoryBuffer(crl_string)
+    cptr=m2.x509_crl_read_pem(bio._ptr())
+    if cptr is None:
+        raise X509Error(Err.get_error())
+    return CRL(cptr, 1)
+
 
diff -Naur M2Crypto-0.21.1.orig/SWIG/_ssl.i M2Crypto-0.21.1.pulp/SWIG/_ssl.i
--- M2Crypto-0.21.1.orig/SWIG/_ssl.i	2011-08-29 11:00:49.305948002 -0400
+++ M2Crypto-0.21.1.pulp/SWIG/_ssl.i	2011-08-29 12:18:14.903476499 -0400
@@ -24,7 +24,11 @@
 %apply Pointer NONNULL { SSL * };
 %apply Pointer NONNULL { SSL_CIPHER * };
 %apply Pointer NONNULL { STACK_OF(SSL_CIPHER) * };
-%apply Pointer NONNULL { STACK_OF(X509) * };
+/* Allowing STACK_OF(X509) to be a null pointer for methods
+   such as X509_STORE_CTX_init, which uses a NULL STACK_OF(X509)
+   to signify no untrsuted chain will be used.
+*/
+/*%apply Pointer NONNULL { STACK_OF(X509) * };*/
 %apply Pointer NONNULL { BIO * };
 %apply Pointer NONNULL { DH * };
 %apply Pointer NONNULL { RSA * };
@@ -812,6 +816,13 @@
 X509 *sk_x509_value(STACK_OF(X509) *stack, int idx) {
     return sk_X509_value(stack, idx);
 }
+
+int sk_x509_crl_num(STACK_OF(X509_CRL) *stack) {
+    return sk_X509_CRL_num(stack);
+}
+X509_CRL *sk_x509_crl_value(STACK_OF(X509_CRL) *stack, int idx) {
+    return sk_X509_CRL_value(stack, idx);
+}
 %}
 
 %threadallow i2d_ssl_session;
diff -Naur M2Crypto-0.21.1.orig/SWIG/_x509.i M2Crypto-0.21.1.pulp/SWIG/_x509.i
--- M2Crypto-0.21.1.orig/SWIG/_x509.i	2011-08-29 11:00:49.304947501 -0400
+++ M2Crypto-0.21.1.pulp/SWIG/_x509.i	2011-08-30 15:34:51.679244001 -0400
@@ -12,6 +12,7 @@
 %{
 #include <openssl/x509.h>
 #include <openssl/x509v3.h>
+#include <openssl/x509_vfy.h>
 %}
 
 %apply Pointer NONNULL { BIO * };
@@ -20,6 +21,8 @@
 %apply Pointer NONNULL { X509_REQ * };
 %apply Pointer NONNULL { X509_NAME * };
 %apply Pointer NONNULL { X509_NAME_ENTRY * };
+%apply Pointer NONNULL { X509_STORE * };
+%apply Pointer NONNULL { X509_STORE_CTX * };
 %apply Pointer NONNULL { EVP_PKEY * };
 
 #if OPENSSL_VERSION_NUMBER >= 0x0090800fL
@@ -37,6 +40,10 @@
 extern void X509_CRL_free(X509_CRL *);
 %rename(x509_crl_new) X509_CRL_new;
 extern X509_CRL * X509_CRL_new();
+%rename(x509_store_ctx_new) X509_STORE_CTX_new;
+extern X509_STORE_CTX *X509_STORE_CTX_new( void );
+%rename(x509_store_ctx_init) X509_STORE_CTX_init;
+extern int X509_STORE_CTX_init( X509_STORE_CTX *, X509_STORE *, X509 *, STACK_OF(X509) *);
 
 %rename(x509_print) X509_print;
 %threadallow X509_print;
@@ -55,6 +62,8 @@
 extern int X509_set_pubkey(X509 *, EVP_PKEY *);
 %rename(x509_get_issuer_name) X509_get_issuer_name;
 extern X509_NAME *X509_get_issuer_name(X509 *);
+%rename(x509_crl_get_issuer) X509_CRL_get_issuer;
+extern X509_NAME *X509_CRL_get_issuer(X509_CRL *);
 %rename(x509_set_issuer_name) X509_set_issuer_name;
 extern int X509_set_issuer_name(X509 *, X509_NAME *);
 %rename(x509_get_subject_name) X509_get_subject_name;
@@ -108,6 +117,8 @@
 
 %rename(x509_verify) X509_verify;
 extern int X509_verify(X509 *a, EVP_PKEY *r);
+%rename(x509_verify_cert) X509_verify_cert;
+extern int X509_verify_cert(X509_STORE_CTX *ctx);
 %rename(x509_get_verify_error) X509_verify_cert_error_string;
 extern const char *X509_verify_cert_error_string(long);
 
@@ -152,6 +163,18 @@
 %rename(x509_name_print_ex_fp) X509_NAME_print_ex_fp;
 extern int X509_NAME_print_ex_fp(FILE *, X509_NAME *, int, unsigned long);
 
+/* JWM: Desire is for x509_name_hash to match up to openssl's version.
+   If the old version is desired, call it expliticlty.
+*/
+%rename(x509_name_hash) X509_NAME_hash;
+extern unsigned long X509_NAME_hash(X509_NAME *);
+
+#if OPENSSL_VERSION_NUMBER >= 0x10000000L
+%rename(x509_name_hash_old) X509_NAME_hash_old;
+extern unsigned long X509_NAME_hash_old(X509_NAME *);
+#endif
+
+/*
 #if OPENSSL_VERSION_NUMBER >= 0x10000000L
 %rename(x509_name_hash) X509_NAME_hash_old;
 extern unsigned long X509_NAME_hash_old(X509_NAME *);
@@ -159,6 +182,7 @@
 %rename(x509_name_hash) X509_NAME_hash;
 extern unsigned long X509_NAME_hash(X509_NAME *);
 #endif
+*/
 
 %rename(x509_name_get_index_by_nid) X509_NAME_get_index_by_NID;
 extern int X509_NAME_get_index_by_NID(X509_NAME *, int, int);
@@ -231,6 +255,14 @@
 %rename(x509_store_add_cert) X509_STORE_add_cert;
 extern int X509_STORE_add_cert(X509_STORE *, X509 *);
 
+%rename(x509_store_add_crl) X509_STORE_add_crl;
+extern int X509_STORE_add_crl(X509_STORE*, X509_CRL* );
+%rename(x509_store_set_flags) X509_STORE_set_flags;
+extern int X509_STORE_set_flags(X509_STORE*, unsigned int );
+%rename(x509_store_ctx_set0_crls) X509_STORE_CTX_set0_crls;
+extern void X509_STORE_CTX_set0_crls(X509_STORE_CTX *ctx, STACK_OF(X509_CRL) *);
+
+
 %rename(x509_store_ctx_get_current_cert) X509_STORE_CTX_get_current_cert;
 extern X509 *X509_STORE_CTX_get_current_cert(X509_STORE_CTX *);
 %rename(x509_store_ctx_get_error) X509_STORE_CTX_get_error;
@@ -315,6 +347,27 @@
             XN_FLAG_DN_REV | \
             XN_FLAG_DUMP_UNKNOWN_FIELDS);
 
+/* x509_vfy.h */
+%constant int X509_V_FLAG_CB_ISSUER_CHECK             = 0x1;
+%constant int X509_V_FLAG_USE_CHECK_TIME              = 0x2;
+%constant int X509_V_FLAG_CRL_CHECK                   = 0x4;
+%constant int X509_V_FLAG_CRL_CHECK_ALL               = 0x8;
+%constant int X509_V_FLAG_IGNORE_CRITICAL             = 0x10;
+%constant int X509_V_FLAG_X509_STRICT                 = 0x20;
+%constant int X509_V_FLAG_ALLOW_PROXY_CERTS           = 0x40;
+%constant int X509_V_FLAG_POLICY_CHECK                = 0x80;
+%constant int X509_V_FLAG_EXPLICIT_POLICY             = 0x100;
+%constant int X509_V_FLAG_INHIBIT_ANY                 = 0x200;
+%constant int X509_V_FLAG_INHIBIT_MAP                 = 0x400;
+%constant int X509_V_FLAG_NOTIFY_POLICY               = 0x800;
+
+%constant int X509_VP_FLAG_DEFAULT                    = 0x1;
+%constant int X509_VP_FLAG_OVERWRITE                  = 0x2;
+%constant int X509_VP_FLAG_RESET_FLAGS                = 0x4;
+%constant int X509_VP_FLAG_LOCKED                     = 0x8;
+%constant int X509_VP_FLAG_ONCE                       = 0x10;
+
+
 /* Cribbed from rsa.h. */
 %constant int RSA_3                           = 0x3L;
 %constant int RSA_F4                          = 0x10001L;
@@ -419,6 +472,10 @@
     return X509_sign(x, pkey, md);
 }
 
+/* x509_CRL_verify() is a macro */
+int x509_crl_verify(X509_CRL *crl, EVP_PKEY *pkey){
+    return X509_CRL_verify(crl, pkey);
+}
 /* XXX The first parameter is really ASN1_TIME, does it matter? */
 ASN1_TIME *x509_gmtime_adj(ASN1_UTCTIME *s, long adj) {
     return X509_gmtime_adj(s, adj);
@@ -464,6 +521,11 @@
     return sk_X509_new_null();
 }
 
+/* sk_X509_crl_new_null() is a macro returning "STACK_OF(X509_CRL) *". */
+STACK_OF(X509_CRL) *sk_x509_crl_new_null(void) {
+    return sk_X509_CRL_new_null();
+}
+
 /* sk_X509_free() is a macro. */
 void sk_x509_free(STACK_OF(X509) *stack) {
     sk_X509_free(stack);
@@ -479,6 +541,21 @@
     return sk_X509_pop(stack);
 }
 
+/* sk_X509_CRL_free() is a macro. */
+void sk_x509_crl_free(STACK_OF(X509_CRL) *stack) {
+    sk_X509_CRL_free(stack);
+}
+
+/* sk_X509_CRL_push() is a macro. */
+int sk_x509_crl_push(STACK_OF(X509_CRL) *stack, X509_CRL *crl) {
+    return sk_X509_CRL_push(stack, crl);
+}
+
+/* sk_X509_CRL_pop() is a macro. */
+X509_CRL *sk_x509_crl_pop(STACK_OF(X509_CRL) *stack) {
+    return sk_X509_CRL_pop(stack);
+}
+
 int x509_store_load_locations(X509_STORE *store, const char *file) {
     return X509_STORE_load_locations(store, file, NULL);
 }
diff -Naur M2Crypto-0.21.1.orig/tests/test_x509.py M2Crypto-0.21.1.pulp/tests/test_x509.py
--- M2Crypto-0.21.1.orig/tests/test_x509.py	2011-08-29 11:00:49.302946499 -0400
+++ M2Crypto-0.21.1.pulp/tests/test_x509.py	2011-08-30 16:08:08.570226499 -0400
@@ -142,7 +142,7 @@
         cn.set_data("Hello There!")
         assert cn.get_data().as_text() == "Hello There!", cn.get_data().as_text()
 
-        assert n.as_hash() == 1697185131
+        assert n.as_hash() == 333998119
         
         self.assertRaises(IndexError, lambda: n[100])
         self.assert_(n[10])
