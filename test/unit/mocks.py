#!/usr/bin/python
#
# Copyright (c) 2010 Red Hat, Inc.
#
#
# This software is licensed to you under the GNU General Public License,
# version 2 (GPLv2). There is NO WARRANTY for this software, express or
# implied, including the implied warranties of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2
# along with this software; if not, see
# http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.
#
# Red Hat trademarks are not licensed under GPLv2. No permission is
# granted to use or replicate Red Hat trademarks that are incorporated
# in this software or its documentation.

import pulp.server.agent

class MockRepoProxy(object):
    '''
    Mock proxy to make calls against a consumer's repo service.
    '''

    def __init__(self, uuid, **options):
        self.bind_data = None
        self.unbind_repo_id = None
        self.update_calls = []

        self.uuid = uuid
        self.options = options

    def bind(self, repo_id, bind_data):
        self.repo_id = repo_id
        self.bind_data = bind_data

    def unbind(self, repo_id):
        self.unbind_repo_id = repo_id

    def update(self, repo_id, bind_data):
        self.update_calls.append((repo_id, bind_data))

    def clear(self):
        '''
        Removes all state from the mock. Meant to be run between test runs to ensure a
        common starting point.
        '''
        self.bind_data = None
        self.unbind_repo_id = None
        self.update_calls = []

class MockRepoProxyFactory(object):
    '''
    When activated, the repo proxy retrieval will return MockRepoProxy instances
    generated by this instance. The instance will store references to the mock proxies
    by uuid to simulate multiple consumers. The proxies used can then be retrieved
    to validate what data was sent to what proxy (i.e. which consumer).
    '''

    def __init__(self):
        self.proxies = {}

    def activate(self):
        '''
        Installs the current factory in the proxy retrieval hook. This will override
        any factories that have already been activated.
        '''

        pulp.server.agent.retrieve_repo_proxy = self.retrieve_mock_proxy

    def retrieve_mock_proxy(self, uuid, **options):
        '''
        Overrides the retrieve_proxy call to return a mock.
        '''

        if uuid not in self.proxies:
            self.proxies[uuid] = MockRepoProxy(uuid, **options)

        return self.proxies[uuid]

    def clear(self):
        '''
        Removes the cache of proxies used.
        '''
        self.proxies.clear()

class MockCdsDispatcher(object):

    # Strings to add to the call_log so the test can verify that the correct calls
    # were made into the dispatcher
    INIT = 'init'
    RELEASE = 'release'
    SYNC = 'sync'
    SET_GLOBAL_REPO_AUTH = 'set_global_repo_auth'
    SET_REPO_AUTH = 'set_repo_auth'

    def __init__(self, error_to_throw=None):
        '''
        Creates a new mock dispatcher that should be added to any CDS classes that
        make dispatcher calls (likely just the CdsApi class). All method calls on
        this object will be added to a running list called call_log. All entries in
        that list will follow the format provided by the call_log_message method.

        @param error_to_throw: if this is specified, any calls into this object will
                               throw the given error, otherwise the method will appear
                               to execute correctly; defaults to None
        @type  error_to_throw: L{Exception} or subclass
        '''
        self.error_to_throw = error_to_throw
        self.call_log = []

        # Stores the values that were passed into calls
        self.cds = None
        self.repos = None
        self.repo_id = None
        self.repo_relative_path = None

    def init_cds(self, cds):
        self.call_log.append(self.call_log_message(MockCdsDispatcher.INIT, cds))
        self.cds = cds

        if self.error_to_throw is not None:
            raise self.error_to_throw

    def release_cds(self, cds):
        self.call_log.append(self.call_log_message(MockCdsDispatcher.RELEASE, cds))
        self.cds = cds
        if self.error_to_throw is not None:
            raise self.error_to_throw

    def sync(self, cds, repos):
        self.call_log.append(self.call_log_message(MockCdsDispatcher.SYNC, cds))
        self.cds = cds
        self.repos = repos

        if self.error_to_throw is not None:
            raise self.error_to_throw

    def set_global_repo_auth(self, cds, cert_bundle):
        self.call_log.append(self.call_log_message(MockCdsDispatcher.SET_GLOBAL_REPO_AUTH, cds))
        self.cert_bundle = cert_bundle

        if self.error_to_throw is not None:
            raise self.error_to_throw

    def set_repo_auth(self, cds, repo_id, repo_relative_path, cert_bundle):
        self.call_log.append(self.call_log_message(MockCdsDispatcher.SET_REPO_AUTH, cds))
        self.repo_id = repo_id
        self.repo_relative_path = repo_relative_path
        self.cert_bundle = cert_bundle

        if self.error_to_throw is not None:
            raise self.error_to_throw
        
    def call_log_message(self, type, cds):
        '''
        Generates the message that will be logged to call_log when a method is invoked.
        This is largely to ease the comparison between what's put in the log against
        what the test case wants to verify.

        @param type: string identifying the method called; will be a constant in this class
        @type  type: string

        @param cds: CDS domain object that was passed to the invoked method
        @type  cds: L{CDS}
        '''
        return type + '-' + cds['hostname']

    def clear(self):
        '''
        Resets the state of the dispatcher to as if it were never called.
        '''
        self.cds = None
        self.repos = None
        self.call_log = []
