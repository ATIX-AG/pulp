= Basics =

 * Plugin instances are accessed through the Plugin Manager. References to these instances should not be cached in Pulp; the appropriate instance should be retrieved from the Plugin Manager each time it is needed.
  * The Plugin Manager is responsible for the loading of plugins and retrieval of instances used to do work for a particular repo. Consult that documentation for more details.
 * Plugins are stateless. Any information needed is passed in at the time of the call. This simplifies cases where configuration changes and restoring Pulp state on a restart.
 * With the exception of the Pulp conduits, all data passed into a plugin is a copy rather than an object reference that may be used elsewhere within Pulp. This is, among other things, a security feature to isolate the plugin's ability to affect the running Pulp server.
 * The only way for a plugin to make calls into the Pulp server is through a ''conduit'' instance. These conduits are special APIs that only allow a subset of Pulp server-side functionality to be accessed to lock down the types of operations the plugin can take on the Pulp server.

----
----

= Standard Types =

There are a number of parameters that are used in multiple API calls. Rather than repeat their description and to help paint an overall picture, their descriptions are provided here.

=== Repository Metadata ===
 * Dictionary of data, stored in Pulp, that describes a repository.
 * This is only data about the repository itself and not the individual importer/distributor configurations.
 * This is likely to be of lesser importance to the plugin than the plugin configuration itself.
 * Includes: name, id, description, sync information (schedule, last sync, etc), checksum type, notes (key-value pairs meant for tagging purposes, not configuration)

=== Plugin Configuration ===
 * Dictionary of data on a per-repo basis that indicates how each attached plugin (importer, distributors) will function.
 * The contents vary depending on the plugin.
 * This is passed to the plugin on each call to prevent Pulp from needing to manage state of the plugins.
 * Includes (for the RPM case): feed URL, preserve metadata flag, use symlinks flag, feed authentication information

=== Standard Unit Metadata ===
 * Dictionary of standard (i.e. Pulp-defined) data describing an individual content unit.
 * This is a least common denominator across all content unit types.
 * Since these fields are required for all content units, Pulp can make assumptions about their presence in the unit metadata.
 * Includes: name, id (unique to the content type), type, description (may be blank), checksum, local filesystem location, size

=== Custom Unit Metadata ===
 * Dictionary of type-specific fields describing an individual content unit.
 * Stored in the Pulp database along with the standard unit metadata.
 * Pulp does not know how to interpret its contents; they are arbitrary JSON based on the needs of the type.
 * Includes (for the RPM case): version, release, epoch, arch, vendor, license

----
----

= Importers =

== Importer API ==

The following APIs will be implemented by importers. An instance of the importer class will be used to handle these calls (note the above comments on these instances being stateless to simplify our handling of these instances).

=== {{{sync(repo_data, plugin_config, individual_sync_config, pulp_importer_sync_conduit)}}} ===

'''Overview'''
 * Called from Pulp into an importer to sync a repository.
 * This call is synchronous from the point of view of the importer; Pulp's asynchronous tasking system will be used to manage any concurrency in its execution.

'''Parameters'''
 * ''Repository Data'' - See above.
 * ''Plugin Config'' - See above.
 * ''Individual Sync Config'' - Similar to plugin config, this is a one-time dictionary of properties to override the default plugin config. This is optional for any sync call; the user may elect to use the defaults configured at repo creation time (i.e. the plugin config).
 * ''Pulp Importer Sync Conduit'' - Callback into Pulp that provides a way for the importer to affect the Pulp server in a controlled way. See below for the sort of API provided.

'''Return'''
 * None (all feedback done through the conduit)

=== {{{pre_import_unit(repo_data, plugin_config, unit_data)}}} ===

'''Overview'''
 * The Pulp server supports the infrastructure around content unit upload (chunking, cancelling, etc) to prevent plugins from needing to duplicate it.
 * Called before the client initiates the bits upload as a check to see if the importer would outright deny the import.

'''Parameters'''
 * ''Repository Data'' - See above.
 * ''Plugin Config'' - See above.
 * ''Unit Data'' - See above.

'''Return'''
 * Indication of whether or not the content unit may be imported.
 * If it cannot be imported, the importer will provide an explanation as to why.
 * One of the following states will be returned:
  * ALLOW - The import should proceed as normal.
  * NO_BITS - The import may be called but the bits are not required. The likely reason is that it represents a duplicate package and the upload would be pointless.
  * UNALLOWED - For whatever reason, the content unit may not be imported into the repository. Some form of message will be provided to indicate the reason.

=== {{{import_unit(repo_data, plugin_config, unit_data, unit_temp_location)}}} ===

'''Overview'''
 * If the call to {{{pre_import_unit}}} indicates the unit should be imported, Pulp performs completes the unit upload before coming back to the importer to import the unit into the repo.
 * This call is responsible for moving the unit bits from the temporary location into whatever file structure it wishes to maintain.

'''Parameters'''
 * See {{{pre_import_unit}}}.
 * ''Unit Temporary Location'' - Full path on disk to the unit's bits to import.

'''Return'''
 * Indication of the success of the import.

=== {{{delete_repo(repo_data, plugin_config, pulp_repo_delete_conduit)}}} ===

'''Overview'''
 * Called when a repo that has been synchronized using this importer is being deleted.
 * The importer is responsible for cleanup of content units of types supported by the importer.
 * The intention here is to give the importer an opportunity to optimize it's content unit storage and only delete units that are no longer in use.

'''Parameters'''
 * ''Repository Data'' - See above.
 * ''Plugin Config'' - See above.
 * ''Plugin Repo Delete Conduit'' - Similar to how a specific API into Pulp is exposed at sync time, this provides Pulp server-side operations the importer will need during delete.

'''Return'''
 * None (all feedback done through the conduit)

'''Notes'''
 * This gets uglier if we entertain a multiple-importer architecture.

=== {{{clone_repo(existing_repo_data, plugin_config, cloned_repo_data, clone_options, pulp_clone_conduit}}} ===

'''Overview'''
 * In addition to "importing" content, the importer is responsible for performing any clone-related operations.
 * This may affect the locations of stored content on disk (for instance, adding symlinks into the cloned repository).
 * It is the responsibility of the importer to make the appropriate callback into Pulp to create the references from the repo clone to the existing content unit documents in the database.

'''Parameters'''
 * ''Existing Repository Data'' - See above. Note that clone filters are part of the general repository data and will be included in here. It is up to the importer to determine if anything needs to be done with that information.
 * ''Plugin Config'' - See above.
 * ''Cloned Repository Data'' - Describes the repository being created from the clone. This will follow the format above for repository data.
 * ''Clone Options'' - Dictionary of options to dictate how the clone will be created supplied by the user with the clone call. The contents will vary based on the importer.
 * ''Pulp Clone Conduit'' - Provides query functionality and the ability to associate existing content units to the cloned repository (current thinking is that the importer will not be able to create new units through this conduit).

'''Return'''
 * None (all feedback done through the conduit)

=== {{{metadata()}}} ===

'''Overview'''
 * Returns metadata about the importer, including its name, version, and supported types.
 * May eventually be expanded to describe its possible configuration values for verification and discovery purposes.

'''Return'''
 * Dictionary of metadata about the supported capabilities of the importer. At very least, the following will be supported.
  * ''Name'' - Identifies the importer.
  * ''Version'' - Identifies the version of the importer. Importers must be unique with respect to their name/version tuple.
  * ''Types'' - List of content type identifiers to indicate the types supported by the importer.

----

== Pulp Importer Sync Conduit ==

An instance of the Pulp Importer Sync Conduit is passed into the importer on every sync call. It provides access to a limited set of Pulp functionality the importer's sync process will need to function.

=== {{{__init__(repo_id, repo_sync_task_id)}}} ===

'''Overview'''
 * While not part of the API, it's worth mentioning that the conduit is created to correspond to a single repo sync task. This prevents the plugin from making calls that would affect a different repository from the one being syncced (either accidentally or maliciously).

'''Parameters'''
 * ''repo_id'' - For calls to this conduit that affect the repo being syncced (for things such as maintaining the relationship between a content unit and its repo), the conduit stores the repo ID to prevent the possibility that the plugin attempts to change a different repo.
 * ''repo_sync_task_id'' - For calls to this conduit that affect the sync task tracking (for example, setting the progress), the conduit holds on to the task ID so the plugin doesn't have to manage it and can only affect the task it is supposed to.

=== {{{set_progress(current_step, total_steps, message)}}} ===

'''Overview'''
 * Informs the Pulp server of the progress of the repos sync.
 * The importer may call this as many times as appropriate given its knowledge during the sync. Pulp will keep track of the most recent information in the sync task.

'''Parameters'''
 * ''Current Step'' - Used to indicate where in the sync the process is. This may correspond to which package out of the total list is being processed or may have some more general meaning, depending on how the importer wants to implement it.
 * ''Total Steps'' - Used by Pulp to calculate percentage complete.
 * ''Message'' - User-presentable message indicating where in the process the sync is.

'''Return'''
 * None

=== {{{get_unit_filename(relative_path)}}} ===

'''Overview'''
 * Used by the importer to get the full path on disk to store a content unit.
 * This gives Pulp the final say in the full path, allowing Pulp to provide the base location on disk as well as any Pulp-wide (using knowledge across all plugins) directory injection it needs to perform.

'''Parameters'''
 * ''Relative Path'' - The relative path at which the importer determines the content unit should be saved. This allows the importer to provide any logic in terms of parsing the content's metadata and optimizations (for instance, the RPM download's ability to store a single copy of a package).

'''Return'''
 * Full path to where the content unit should be stored.

=== {{{add_content_unit(id, type_id, standard_unit_data, custom_unit_data)}}} ===

'''Overview'''
 * Used by the importer to a synchronized content unit to the Pulp database.
 * The importer may elect to do this on a unit-by-unit basis or wait until the end to add them to the database, depending on how the actual sync is performed.
 * The format for the *_unit_data parameters is key-value pairs.
  * Custom unit data keys cannot be one of the standard unit keys.
  * The *_unit_data dictionaries will be merged into a single dictionary that is stored as the document for that particular content unit.

'''Parameters'''
 * ''ID'' - Identifier unique across other content units ''of the same type''. This will help minimize the potential of different importers stepping on each other while still providing the ability for multiple importers to service the same type. The Pulp server will take care of adding any additional data to this ID to guarantee global uniqueness as required by the database.
 * ''Type ID'' - It's possible a single sync may introduce more than one type of content (for example, a yum sync will introduce RPMs, errata, and kickstart trees). The type ID is used to inform Pulp of what type of content is being added.
 * ''Standard Unit Data'' - See above.
 * ''Custom Unit Data'' - See above.

'''Return'''
 * None

'''Notes'''
 * The fields that are defined as "standard" and will be present for all content units, regardless of type, still need to be determined.
 * There may be some restrictions on the custom unit data format depending on what we find in our Mongo query research. These restrictions may either be enforced in the plugin itself or as a transformation on the data performed on the Pulp side. The intent is to support variable schemas of metadata while still ensuring reasonably querying against the data.

----

== Pulp Repo Delete Conduit ==

An instance of this is passed to the importer instance with the delete repo call. This provides a way for the importer to query the Pulp server for more information on the repo than what is provided in the repo data passed in the delete call.

=== {{{query_units(?)}}} ===

'''Overview'''
 * A flexible mechanism to query the units contained in the repository.
 * This needs to support more fine-grained queries than simply returning a list of all units in the repository.

'''Parameters'''
 * TBD

'''Return'''
 * A list of content unit dictionaries.

=== {{{query_unit_repos(?)}}} ===

'''Overview'''
 * Repository membership is not tracked in the content unit domain model. This call is intended to allow the importer to determine what other repositories are serving a specific content unit.
 * We may be able to play around with the signature to optimize the number of calls the importer has to make to determine which units are orphaned, either through this call or a separate orphaned query.

'''Parameters'''
 * TBD

'''Return'''
 * TBD

=== {{{delete_unit(unit_id)}}} or {{{purge_orphans(package_id_list)}}} ===

'''Overview'''
 * The intention here is to provide a way to clean out the content unit domain model for units no longer served by repositories.
 * Either the import can be given an explicit conduit to delete a unit or simply a call to the Pulp server to make the determination of orphaned units and delete those.

'''Parameters'''
 * TBD

'''Return'''
 * TBD

----

== Pulp Clone Repo Conduit ==

An instance of this is passed to the importer instance with the clone repo call. This conduit provides queries needed by the importer to perform a clone as well as the ability to create references from the existing content units to the newly created repository. This conduit will ''not'' allow the importer to create new units in the Pulp database.

----
----

= Distributors =

The following APIs will be implemented by distributors. An instance of the distributor class will be used to handle these calls (note the above comments on these instances being stateless to simplify our handling of these instances).

== Distributor API ==

=== {{{publish(repo_data, plugin_config, individual_publish_config, pulp_repo_publish_conduit)}}} ===

'''Overview'''
 * Performs whatever steps are necessary to take the latest content in the repository and make it accessible.
 * The Pulp repository will have to keep track if this call is automatically triggered on the tail end of an importer sync or must be manually triggered (or support for both). The reason for this distinction is the case of generating an ISO/image from a repository, which may not be desired automatically following a sync. This distinction may be a new feature added after the initial implementation.
 * A publish takes place in an asynchronous task, much like a repo sync operation, due to the potentially long running nature of it. The set_progress callback in the publish conduit should be used to keep the Pulp server aware of the publish progress.

'''Parameters'''
 * ''Repository Data'' - See above.
 * ''Plugin Config'' - See above.
 * ''Individual Sync Config'' - Similar to plugin config, this is a one-time dictionary of properties to override the default plugin config. This is optional for any manually triggered publish call. One use case of this is an ISO creation distributor that would allow the user to specify the filename when the publish takes place (assuming it's manually triggered; automatic publishes triggered at the tail end of a sync will use the values in the plugin config itself).

'''Return'''
 * None (all feedback done through the conduit)

=== {{{unpublish(repo_data, plugin_config, individual_unpublish_config)}}} ===

'''Overview'''
 * May not be supported by all distributors (might be able to find a cleaner way than just throwing a NotImplemented exception)

'''Parameters'''
 * ''Repository Data'' - See above.
 * ''Plugin Config'' - See above.
 * ''Individual Unpublish Config'' - One-time dictionary of properties that apply to the unpublish call. 

=== {{{metadata()}}} ===

'''Overview'''
 * Very similar to the method of the same name in the Importer API. See the definition in that API for more details on return type.

----

== Pulp Repo Publish Conduit ==

=== {{{__init__(repo_id, repo_publish_task_id)}}} ===

'''Overview'''
 * The concept in the conduits is similar; store the information that identifies the work being done in the conduit so the plugin doesn't have to manage it to report or change its state.

=== {{{set_progress(current_step, total_steps, message)}}} ===

'''Overview'''
 * See the set_progress method in the repo sync conduit for more information on parameters and return type.
 * This becomes important to track for potentially long running publish operations such as creating an ISO or image from a repository.

'''Parameters'''
 * See {{{set_progress}}} above.

----
----

= Consumer Profilers =

Consumer profilers are slightly different plugins than importers and distributors. Profilers are focused around analyzing a consumer's package profile and bound repos and making determinations about units that can be installed.

When a consumer sends its profile to the server, it indicates the format type of the profile. That format indication is how Pulp will resolve which profiler to use when analyzing the profile. A consumer may submit multiple profiles, each with a different format type. The expectation is that formats will be divided out in such a way that similar types are included in the same format (this is, of course, up to the discretion of the profiler implementer).

== Profiler API ==

The following API is implemented by consumer profiler plugins. Callbacks into the Pulp server are done through conduit instances passed into the calls.

Most conduits passed to profiler calls will only need to expose queries and progress callbacks. Therefore, unless we find the need otherwise, a single conduit implementation (not necessarily instance) will be used in all cases.

I think we need to account for the potential for these operations to be somewhat time consuming, especially if we enhance these APIs to analyze multiple consumers at the same time and return set based results (union, intersection). Therefore, the conduit will provide a progress callback so the plugin can keep the server up to date with where it is in the process.

=== {{{installable(consumer_profile, bound_repos_data, plugin_config, profiler_conduit, type_ids?)}}} ===

'''Overview'''
 * Asks the plugin to analyze a consumer profile and return a list of all content units that are available to it (through bound repos) and that may be installed.
  * The concept of "may be installed" is open to interpretation by the plugin. This may be as simple as what's in the repo but not on the consumer or as complicated as taking into account incompatibilities with other installed units. Another possibility is for the repo to contain multiple versions of a unit but the plugin to only indicate the most recent version is available for installation.
 * The big drive for this concept is for repos that contain a number of different types of files. It is possible that some are not directly installable but rather are included as part of a different unit installation (for instance, think of parent-child relationships; the profiler may apply that knowledge to not allow the child to be installed outside of the parent).

'''Parameters'''
 * Consumer Profile - The profile of the consumer's units as provided by the consumer. The contents will vary based on the format it is in, which is indicated with the profile.
 * Bound Repository Data - List of repo metadata for each repo the given consumer is bound to.
 * Plugin Configuration - See above.
 * Profiler Conduit - Provides a query mechanism into Pulp the plugin may use to determine more information on units contained within a repository.
 * Type IDs - If specified, only installable units of the given types will be returned. The return may also indicate if one or more of the units is "unsafe" to install given that it has a dependency on units in types not specified in this list.

=== {{{removable(consumer_profile, bound_repos_data, plugin_config, profiler_conduit, type_ids?)}}} ===

'''Overview'''
 * This call is very similar to installable, with the obvious difference that it returns a list of packages that may be removed through Pulp.
  * See {{{installable}}} for a description of parameters and their explanations.
 * This step is necessary to, at very least, resolve the profile's representation of a unit against the Pulp unit ID.
 * The returned list may not necessarily be everything in the profile. The plugin may want to apply it's own knowledge to prevent the removal of system critical units that are included in the profile.

=== {{{upgradable(consumer_profile, bound_repos_data, plugin_config, profiler_conduit, type_ids?)}}} ===

'''Overview'''
 * Again, this is similar to installable, but arguably much more useful.
  * See {{{installable}}} for a description of parameters and their explanations.
 * This call will return information on what units exist on the consumer that have newer versions present in the consumer's bound repositories.
  * How this is represented/communicated still needs to be decided. A first pass may be to simply return the newest version of all upgradable units, with the eventual improvement of being able to indicate more information in the future.
             

