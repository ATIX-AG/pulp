[[TOC]]
= Coordinator =

== Introduction ==
Pulp manages a number of resources such as repositories, consumers, contents, 
etc. It can perform operations on these resources in parallel. Create, read,
update, and delete operations may occur simaltaniously on the same resource.

The coordinator is a package in Pulp that will track resources and the 
operations they are currently undergoing. The module will identify conflicting 
operations and take the appropriate actions.

The coordinator is built on top of Pulp's tasking sub-system and will require 
enhancements to it in order to fullfill it's purpose.

----

== Design ==
The coordinator is a scheduling system. It is given three pieces of 
information when something request an operation on a resource:
 1. the resource's unique id
 1. the type of the resource
 1. the type of the operation

Using this information, the coordinator decerns if any conflicting operations 
are currently executing against that resource. If conflicting operations are 
found, the coordinator determines if the conflicts exclude the requested 
operation or postpones the opertation.

If there are no conclifting operations, the coordinator executes the opertion
and returns the results.

If the requested operation is postponed, the coordinator will hand it over to 
the tasking sub-system and return the task information.

If the requested operation is excluded, the coordinator returns an error 
detailing why the operation wasn't allowed to execute. 

The coordinator will also honor executing operations asynchronously in the 
tasking sub-system on request, regardless of no coflicts. It will will still 
error if an excluding operation is in progress.
 
=== Resource Id and Types ==
Pulp manages a number or resource types that can be considered ''primitives'' 
for the purposes of resource tracking. Each resource's id is unique with the 
set of its type. Rource types refer to the model representing individual 
resources and each resource's id is already unique via database constraints.

Resource types are:
 * CDS
 * Consumer
 * !ContentUnit
 * Repo

'''XXX''': how do we handle aggregate types like consumer groups?

=== Operations ===
All manager API calls in Pulp can be mapped to a set of CRUD operations on the 
resources they're called on. For an arbitrary individual resource, the 
following table shows how CRUD operations conflict:

|'''Operation'''|'''No Conflict'''|'''Postpones'''|'''Excludes'''|
|Create||Read, Update, Delete|Create|
|Read|Read|Create, Update, Delete||
|Update||Create, Read, Update, Delete||
|Delete||Create|Read, Update, Delete|

Mapping the API calls to resources and operations is the providence of the 
programmer and consideration must be given. Not all mappings are straight 
forward. For example: the repo sync call will be an `Update` operation simply 
because it changes some fields of the Repo resource as a side-effect.

----

== Implementation ==
The Coordinator will provide a public API that will execute manager API calls 
under the above contraints.

=== Coordinator API ===

'''Execution Functions: run, run_async, run_sync'''

{{{
#!python
def run(call, args, kwargs, resources_map)
}}}

The `run` method is the primary method of the coordinator's API and exhibits 
the behavior detailed above.

Arguments:
 * `call` - manager API method instance
 * `args` - (optional) list of positional arguments to pass to `call`
 * `kwargs` - (optional) dict of keyword arguments to pass to `call`
 * `resource_map` - dict of resource_type: dict of resource_id: list of operations

The `run` call does no introspection on any of the first 3 arguments to 
determine the resources or operations. Instead it relies on the `resource_map` 
to be explicity told what they are. 

For example a `resource_map` for a repo clone call may look like:
{{{
#!python
{Repo: {'repo_parent': ['READ'],
       {'repo_dolly': ['CREATE'],}
}}}

----

{{{
#!python
def run_async(call, args, kwargs, resources_map, pre_exec_hook, post_exec_hook, cancel_hook, timeout_hook)
}}}

The `run_async` function will run the call asynchronously in the tasking 
sub-system regardless of there being no postponing operations in progress.

----

{{{
#!python
def run_sync(call, args, kwargs, resources_map, timeout)
}}}

----

'''Return Type: execution_state'''

== Proof ==

